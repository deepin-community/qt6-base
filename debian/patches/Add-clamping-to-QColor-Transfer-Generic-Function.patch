Author: Tian Shilin<tianshilin@uniontech.com>
Date:   Wed Dec 17 16:49:00 2025
Subject: Add clamping to QColor Transfer Generic Function
Upstream: https://codereview.qt-project.org/c/qt/qtbase/+/628360ï¼Œhttps://codereview.qt-project.org/c/qt/qtbase/+/647919

---

Index: qt6-base/src/gui/painting/qcolortransfergeneric_p.h
===================================================================
--- qt6-base.orig/src/gui/painting/qcolortransfergeneric_p.h
+++ qt6-base/src/gui/painting/qcolortransfergeneric_p.h
@@ -17,6 +17,7 @@
 
 #include <QtGui/private/qtguiglobal_p.h>
 
+#include <algorithm>
 #include <cmath>
 
 QT_BEGIN_NAMESPACE
@@ -65,6 +66,7 @@ private:
     // HLG from linear [0-12] -> [0-1]
     static float hlgFromLinear(float x)
     {
+        x = std::clamp(x, 0.f, 12.f);
         if (x > 1.f)
             return m_hlg_a * std::log(x - m_hlg_b) + m_hlg_c;
         return std::sqrt(x * 0.25f);
@@ -73,6 +75,7 @@ private:
     // HLG to linear [0-1] -> [0-12]
     static float hlgToLinear(float x)
     {
+        x = std::clamp(x, 0.f, 1.f);
         if (x < 0.5f)
             return (x * x) * 4.f;
         return std::exp((x - m_hlg_c) / m_hlg_a) + m_hlg_b;
@@ -82,18 +85,32 @@ private:
     constexpr static float m_hlg_b = 1.f - (4.f * m_hlg_a);
     constexpr static float m_hlg_c = 0.55991073f; // 0.5 - a * ln(4 * a)
 
-    // PQ to linear [0-1] -> [0-64]
-    static float pqToLinear(float x)
+    // BT.2100-2 Reference PQ EOTF and inverse (see Table 4)
+    static float pqToLinear(float e)
     {
-        x = std::pow(x, 1.f / m_pq_m2);
-        return std::pow((m_pq_c1 - x) / (m_pq_c3 * x - m_pq_c2), (1.f / m_pq_m1)) * m_pq_f;
+        e = std::clamp(e, 0.f, 1.f);
+        // m2-th root of E'
+        const float eRoot = std::pow(e, 1.f / m_pq_m2);
+        // rational transform
+        const float yBase = (std::max)(eRoot - m_pq_c1, 0.0f) / (m_pq_c2 - m_pq_c3 * eRoot);
+        // calculate Y = yBase^(1/m1)
+        const float y = std::pow(yBase, 1.f / m_pq_m1);
+        // scale Y to Fd
+        return y * m_pq_f;
     }
 
     // PQ from linear [0-64] -> [0-1]
-    static float pqFromLinear(float x)
+    static float pqFromLinear(float fd)
     {
-        x = std::pow(x * (1.f / m_pq_f), m_pq_m1);
-        return std::pow((m_pq_c1 + m_pq_c2 * x) / (1.f + m_pq_c3 * x), m_pq_m2);
+        fd = std::clamp(fd, 0.f, 64.f);
+        // scale Fd to Y
+        const float y = fd * (1.f / m_pq_f);
+        // yRoot = Y^m1 -- "root" because m1 is <1
+        const float yRoot = std::pow(y, m_pq_m1);
+        // rational transform
+        const float eBase = (m_pq_c1 + m_pq_c2 * yRoot) / (1.f + m_pq_c3 * yRoot);
+        // calculate E' = eBase^m2
+        return std::pow(eBase, m_pq_m2);
     }
 
     constexpr static float m_pq_c1 =  107.f / 128.f; // c3 - c2 + 1
