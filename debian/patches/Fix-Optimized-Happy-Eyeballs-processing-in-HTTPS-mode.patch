Author: Tian Shilin<tianshilin@uniontech.com>
Date:   Thu Oct 04 21:20:24 2025
Subject:Fix Improve Happy Eyeballs for HTTPS and HTTP/2 to avoid stalls
Upstream: https://codereview.qt-project.org/c/qt/qtbase/+/680136,https://codereview.qt-project.org/c/qt/qtbase/+/679505

---

Index: qt6-base/src/network/access/qhttpnetworkconnection.cpp
===================================================================
--- qt6-base.orig/src/network/access/qhttpnetworkconnection.cpp
+++ qt6-base/src/network/access/qhttpnetworkconnection.cpp
@@ -173,14 +173,49 @@ bool QHttpNetworkConnectionPrivate::shou
     // If the IPv4 connection still isn't started we need to start it now.
     if (delayedConnectionTimer.isActive()) {
         delayedConnectionTimer.stop();
-        channels[otherSocket].ensureConnection();
+        if (otherSocket >= 0 && otherSocket < activeChannelCount)
+            channels[otherSocket].ensureConnection();
     }
 
     if (activeChannelCount < channelCount) {
-        if (networkLayerState == HostLookupPending || networkLayerState == IPv4or6)
-            networkLayerState = QHttpNetworkConnectionPrivate::Unknown;
-        channels[0].close();
-        emitError = true;
+        if (networkLayerState == HostLookupPending || networkLayerState == IPv4or6) {
+            // Happy Eyeballs race (IPv4or6): one address family can fail early while the other
+            // is still connecting/handshaking (especially HTTPS where selected is decided at TLS encrypted()).
+            // Must not terminate the other channel prematurely.
+
+            const bool otherValid = otherSocket >= 0 && otherSocket < activeChannelCount;
+            const bool otherAlive = otherValid
+                    && channels[otherSocket].isSocketBusy()
+                    && (channels[otherSocket].state != QHttpNetworkConnectionChannel::ClosingState);
+
+            if (otherAlive) {
+                // First channel to fail: close only the failing channel and suppress error reporting.
+                // Continue racing with the other channel.
+                channels[i].close();
+                emitError = false;
+            } else {
+                // Both connection attempts failed (or the other is not active/usable).
+                networkLayerState = QHttpNetworkConnectionPrivate::Unknown;
+                channels[i].close();
+                emitError = true;
+            }
+        } else if (networkLayerState == IPv4 || networkLayerState == IPv6) {
+            // Network layer already decided, check if this is the non-winning channel
+            bool anyProtocol = channels[i].networkLayerPreference == QAbstractSocket::AnyIPProtocol;
+            if ((networkLayerState == IPv4 && channels[i].networkLayerPreference != QAbstractSocket::IPv4Protocol && !anyProtocol)
+                || (networkLayerState == IPv6 && channels[i].networkLayerPreference != QAbstractSocket::IPv6Protocol && !anyProtocol)) {
+                // This is the losing channel, just close it without affecting the winning channel
+                channels[i].close();
+                emitError = false;
+            } else {
+                // This is the winning channel that failed
+                channels[i].close();
+                emitError = true;
+            }
+        } else {
+            channels[0].close();
+            emitError = true;
+        }
     } else {
         if (networkLayerState == HostLookupPending || networkLayerState == IPv4or6) {
             if (channels[otherSocket].isSocketBusy() && (channels[otherSocket].state != QHttpNetworkConnectionChannel::ClosingState)) {
@@ -195,8 +230,9 @@ bool QHttpNetworkConnectionPrivate::shou
                 emitError = true;
             }
         } else {
-            if (((networkLayerState == QHttpNetworkConnectionPrivate::IPv4) && (channels[i].networkLayerPreference != QAbstractSocket::IPv4Protocol))
-                || ((networkLayerState == QHttpNetworkConnectionPrivate::IPv6) && (channels[i].networkLayerPreference != QAbstractSocket::IPv6Protocol))) {
+            bool anyProtocol = channels[i].networkLayerPreference == QAbstractSocket::AnyIPProtocol;
+            if (((networkLayerState == QHttpNetworkConnectionPrivate::IPv4) && (channels[i].networkLayerPreference != QAbstractSocket::IPv4Protocol && !anyProtocol))
+                || ((networkLayerState == QHttpNetworkConnectionPrivate::IPv6) && (channels[i].networkLayerPreference != QAbstractSocket::IPv6Protocol && !anyProtocol))) {
                 // First connection worked so this is the second one to complete and it failed.
                 channels[i].close();
                 QMetaObject::invokeMethod(q, "_q_startNextRequest", Qt::QueuedConnection);
@@ -646,7 +682,8 @@ QHttpNetworkReply* QHttpNetworkConnectio
     else { // HTTP/2 ('h2' mode)
         if (!pair.second->d_func()->requestIsPrepared)
             prepareRequest(pair);
-        channels[0].h2RequestsToSend.insert(request.priority(), pair);
+        if (h2Index >= 0 && h2Index < channelCount)
+            channels[h2Index].h2RequestsToSend.insert(request.priority(), pair);
     }
 
     // For Happy Eyeballs the networkLayerState is set to Unknown
@@ -671,10 +708,12 @@ QHttpNetworkReply* QHttpNetworkConnectio
 
 void QHttpNetworkConnectionPrivate::fillHttp2Queue()
 {
+    if (h2Index < 0 || h2Index >= channelCount)
+        return;
     for (auto &pair : highPriorityQueue) {
         if (!pair.second->d_func()->requestIsPrepared)
             prepareRequest(pair);
-        channels[0].h2RequestsToSend.insert(QHttpNetworkRequest::HighPriority, pair);
+        channels[h2Index].h2RequestsToSend.insert(QHttpNetworkRequest::HighPriority, pair);
     }
 
     highPriorityQueue.clear();
@@ -682,7 +721,7 @@ void QHttpNetworkConnectionPrivate::fill
     for (auto &pair : lowPriorityQueue) {
         if (!pair.second->d_func()->requestIsPrepared)
             prepareRequest(pair);
-        channels[0].h2RequestsToSend.insert(pair.first.priority(), pair);
+        channels[h2Index].h2RequestsToSend.insert(pair.first.priority(), pair);
     }
 
     lowPriorityQueue.clear();
@@ -1079,28 +1118,30 @@ void QHttpNetworkConnectionPrivate::_q_s
     }
     case QHttpNetworkConnection::ConnectionTypeHTTP2Direct:
     case QHttpNetworkConnection::ConnectionTypeHTTP2: {
-        if (channels[0].h2RequestsToSend.isEmpty() && !channels[0].reply
+        if (h2Index < 0 || h2Index >= channelCount)
+            return;
+        if (channels[h2Index].h2RequestsToSend.isEmpty() && !channels[h2Index].reply
             && highPriorityQueue.isEmpty() && lowPriorityQueue.isEmpty()) {
             return;
         }
 
         if (networkLayerState == IPv4)
-            channels[0].networkLayerPreference = QAbstractSocket::IPv4Protocol;
+            channels[h2Index].networkLayerPreference = QAbstractSocket::IPv4Protocol;
         else if (networkLayerState == IPv6)
-            channels[0].networkLayerPreference = QAbstractSocket::IPv6Protocol;
-        channels[0].ensureConnection();
-        if (auto *s = channels[0].socket; s
+            channels[h2Index].networkLayerPreference = QAbstractSocket::IPv6Protocol;
+        channels[h2Index].ensureConnection();
+        if (auto *s = channels[h2Index].socket; s
             && QSocketAbstraction::socketState(s) == QAbstractSocket::ConnectedState
-            && !channels[0].pendingEncrypt) {
-            if (channels[0].h2RequestsToSend.size()) {
-                channels[0].sendRequest();
-            } else if (!channels[0].reply && !channels[0].switchedToHttp2) {
+            && !channels[h2Index].pendingEncrypt) {
+            if (channels[h2Index].h2RequestsToSend.size()) {
+                channels[h2Index].sendRequest();
+            } else if (!channels[h2Index].reply && !channels[h2Index].switchedToHttp2) {
                 // This covers an edge-case where we're already connected and the "connected"
                 // signal was already sent, but we didn't have any request available at the time,
                 // so it was missed. As such we need to dequeue a request and send it now that we
                 // have one.
-                dequeueRequest(channels[0].socket);
-                channels[0].sendRequest();
+                dequeueRequest(channels[h2Index].socket);
+                channels[h2Index].sendRequest();
             }
         }
         break;
@@ -1315,12 +1356,18 @@ void QHttpNetworkConnectionPrivate::_q_h
 // connection will then be disconnected.
 void QHttpNetworkConnectionPrivate::startNetworkLayerStateLookup()
 {
+    // HTTP/2 Happy Eyeballs: promote activeChannelCount to 2 for dual-stack race
+    if (channelCount >= 2 && activeChannelCount < 2) {
+        activeChannelCount = 2;
+    }
+
     if (activeChannelCount > 1) {
         // At this time all channels should be unconnected.
         Q_ASSERT(!channels[0].isSocketBusy());
         Q_ASSERT(!channels[1].isSocketBusy());
 
         networkLayerState = IPv4or6;
+        h2Index = 0; // Default to IPv4 channel during race
 
         channels[0].networkLayerPreference = QAbstractSocket::IPv4Protocol;
         channels[1].networkLayerPreference = QAbstractSocket::IPv6Protocol;
@@ -1333,6 +1380,7 @@ void QHttpNetworkConnectionPrivate::star
             channels[0].ensureConnection();
     } else {
         networkLayerState = IPv4or6;
+        h2Index = 0; // Single channel mode, use channel 0
         channels[0].networkLayerPreference = QAbstractSocket::AnyIPProtocol;
         channels[0].ensureConnection();
     }
@@ -1340,7 +1388,28 @@ void QHttpNetworkConnectionPrivate::star
 
 void QHttpNetworkConnectionPrivate::networkLayerDetected(QAbstractSocket::NetworkLayerProtocol protocol)
 {
+    // Choose winner index (IPv4 -> 0, IPv6 -> 1) and merge H2 queues to the winner
+    int winner = (protocol == QAbstractSocket::IPv4Protocol) ? 0 : 1;
+    // Ensure winner index is within bounds
+    if (winner >= 0 && winner < channelCount) {
+        h2Index = winner; // Update target channel index
+        for (int i = 0; i < activeChannelCount; ++i) {
+            if (i == winner || i >= channelCount)
+                continue;
+            auto &from = channels[i].h2RequestsToSend;
+            if (!from.isEmpty()) {
+                channels[winner].h2RequestsToSend.unite(from);
+                from.clear();
+            }
+        }
+    }
+
     for (int i = 0 ; i < activeChannelCount; ++i) {
+        if (i >= channelCount)
+            continue;
+        // Don't close channels with AnyIPProtocol preference - they accept any protocol
+        if (channels[i].networkLayerPreference == QAbstractSocket::AnyIPProtocol)
+            continue;
         if ((channels[i].networkLayerPreference != protocol) && (channels[i].state == QHttpNetworkConnectionChannel::ConnectingState)) {
             channels[i].close();
         }
Index: qt6-base/src/network/access/qhttpnetworkconnection_p.h
===================================================================
--- qt6-base.orig/src/network/access/qhttpnetworkconnection_p.h
+++ qt6-base/src/network/access/qhttpnetworkconnection_p.h
@@ -261,6 +261,9 @@ public:
     // early).
     QNetworkConnectionMonitor connectionMonitor;
 
+    // HTTP/2 Happy Eyeballs: pre-computed target channel index
+    int h2Index = 0;
+
     friend class QHttpNetworkConnectionChannel;
 };
 
Index: qt6-base/src/network/access/qhttpnetworkconnectionchannel.cpp
===================================================================
--- qt6-base.orig/src/network/access/qhttpnetworkconnectionchannel.cpp
+++ qt6-base/src/network/access/qhttpnetworkconnectionchannel.cpp
@@ -887,35 +887,55 @@ void QHttpNetworkConnectionChannel::_q_d
 
 void QHttpNetworkConnectionChannel::_q_connected_abstract_socket(QAbstractSocket *absSocket)
 {
-    // For the Happy Eyeballs we need to check if this is the first channel to connect.
-    if (connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::HostLookupPending || connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4or6) {
-        if (connection->d_func()->delayedConnectionTimer.isActive())
-            connection->d_func()->delayedConnectionTimer.stop();
-        if (networkLayerPreference == QAbstractSocket::IPv4Protocol)
-            connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
-        else if (networkLayerPreference == QAbstractSocket::IPv6Protocol)
-            connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
-        else {
-            if (absSocket->peerAddress().protocol() == QAbstractSocket::IPv4Protocol)
+    // Happy Eyeballs winner selection point.
+    // - HTTP: decide winner at TCP connected(), close the other family.
+    // - HTTPS: defer winner selection to TLS encrypted(); keep both families through TLS.
+    if (!connection->d_func()->encrypt) {
+        if (connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::HostLookupPending || connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4or6) {
+            if (connection->d_func()->delayedConnectionTimer.isActive())
+                connection->d_func()->delayedConnectionTimer.stop();
+            QAbstractSocket::NetworkLayerProtocol detectedProtocol;
+            if (networkLayerPreference == QAbstractSocket::IPv4Protocol) {
                 connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
-            else
+                detectedProtocol = QAbstractSocket::IPv4Protocol;
+            } else if (networkLayerPreference == QAbstractSocket::IPv6Protocol) {
                 connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
+                detectedProtocol = QAbstractSocket::IPv6Protocol;
+            } else {
+                // AnyIPProtocol: determine from actual peer address
+                detectedProtocol = absSocket->peerAddress().protocol();
+                if (detectedProtocol == QAbstractSocket::IPv4Protocol)
+                    connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
+                else
+                    connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
+            }
+            connection->d_func()->networkLayerDetected(detectedProtocol);
+            if (connection->d_func()->activeChannelCount > 1)
+                QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
+        } else {
+            bool anyProtocol = networkLayerPreference == QAbstractSocket::AnyIPProtocol;
+            if (((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4)
+                 && (networkLayerPreference != QAbstractSocket::IPv4Protocol && !anyProtocol))
+                || ((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv6)
+                    && (networkLayerPreference != QAbstractSocket::IPv6Protocol && !anyProtocol))) {
+                close();
+                QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
+                return;
+            }
+            // The connection's networkLayerState had already been decided.
         }
-        connection->d_func()->networkLayerDetected(networkLayerPreference);
-        if (connection->d_func()->activeChannelCount > 1 && !connection->d_func()->encrypt)
-            QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
     } else {
+        // HTTPS: do not decide networkLayerState here. If already decided elsewhere,
+        // close the non-matching family's connecting channels.
         bool anyProtocol = networkLayerPreference == QAbstractSocket::AnyIPProtocol;
         if (((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4)
              && (networkLayerPreference != QAbstractSocket::IPv4Protocol && !anyProtocol))
             || ((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv6)
                 && (networkLayerPreference != QAbstractSocket::IPv6Protocol && !anyProtocol))) {
             close();
-            // This is the second connection so it has to be closed and we can schedule it for another request.
             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
             return;
         }
-        //The connections networkLayerState had already been decided.
     }
 
     // improve performance since we get the request sent by the kernel ASAP
@@ -1229,6 +1249,19 @@ void QHttpNetworkConnectionChannel::_q_e
     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket);
     Q_ASSERT(sslSocket);
 
+    if (connection->d_func()->encrypt) {
+        auto st = connection->d_func()->networkLayerState;
+        if (st == QHttpNetworkConnectionPrivate::HostLookupPending || st == QHttpNetworkConnectionPrivate::IPv4or6) {
+            const auto proto = sslSocket->peerAddress().protocol();
+            if (proto == QAbstractSocket::IPv4Protocol)
+                connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
+            else
+                connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
+            // Inform connection to close the other family's connecting channels
+            connection->d_func()->networkLayerDetected(proto);
+        }
+    }
+
     if (!protocolHandler && connection->connectionType() != QHttpNetworkConnection::ConnectionTypeHTTP2Direct) {
         // ConnectionTypeHTTP2Direct does not rely on ALPN/NPN to negotiate HTTP/2,
         // after establishing a secure connection we immediately start sending
